# Procedural Map Generator | Cellular Automata
This is a very simple implementation of map generation using a cellular automaton where a wall or floor tile is generated based on a tile's neighbor count.

## Preview
![Preview](https://s9.gifyu.com/images/SZ87Z.gif)

## How can we implement this?
Before we start, you’ll need a basic understanding of variables, 2d lists, array indexing and loops to understand this tutorial.

First, we generate a noise map, which is just a very not-so-organized map with a bunch of randomized floor and wall tiles. We can accomplish this by having a `generate_noise_map()` function that takes in 3 arguments: `width`, `height` and `fill_percentage`.

Then, we make a list that stores all the noise map’s floor and wall tiles, let’s store this list in a variable called `noise_map`:
```py
noise_map = []
```

After that, we make 2 simple loops to generate the map: The first loop iterates `height` amount of times and appends a list to the noise map’s list at every iteration (so, we’re going to be working with a two-dimensional list), 
```
HEIGHT 1 -> [         ]
HEIGHT 2 -> [         ]
HEIGHT 3 -> [         ]
```

while the second one is nested in the first loop and iterates `width` amount of times. The second loop simply populates the lists generated by the first loop.
```
 ITEM 1    ITEM 2    ITEM 3
   ↓        ↓        ↓
[  X        X        X  ]

 ITEM 4    ITEM 5    ITEM 6
   ↓        ↓        ↓
[  X        X        X  ]

 ITEM 7    ITEM 8    ITEM 9
   ↓        ↓        ↓
[  X        X        X  ]
```

Inside the second loop, we want to generate either a floor or wall tile to populate the current height’s list. We can use a basic chance generator using python’s `random` package, the `fill_percentage` argument and an if-else statement (_TILE_WALL = 1, TILE_FLOOR = 0_):
```py
if random.randint(1, 100) <= fill_percentage:
  noise_map[current_height] = TILE_WALL
else:
  noise_map[current_height] = TILE_FLOOR
```

This would be the complete function for this:
```py
def generate_noise_map(width: int, height: int, fill_percentage: int) -> list:
    # Make the noise_map list
    noise_map = []

    # Iterate "height" amount of times
    for y in range(height):
        # Make a list at every iteration
        noise_map.append([])

        # Iterate "width" amount of times
        for x in range(width):

            # Append wall to the current height's list if random number <= fill_percentage
            if random.randint(1, 100) <= fill_percentage:
                noise_map[y].append(TILE_WALL)
            else:
                # Append floor to the current height's list if random number > fill_percentage
                noise_map[y].append(TILE_FLOOR)

    # Return the noise map
    return noise_map
```
And, boom! We now have a very ugly-looking noise map!
![Noise Map](https://i.ibb.co/fQD5Nty/Screenshot-1.png)<br>

Let’s clean up this map using a cellular automaton (_A cellular automaton is a method of arranging a grid of values into a more organized grid_).

The cellular automaton we’re going to be using simply counts how many wall tiles are surrounding a specific tile. If the count is bigger than 4, that tile is going to turn into a wall tile, if the count is equal or lower than 4, then that tile will become a floor tile. Here’s a demonstration.<br>
![Empty Grid](https://i.ibb.co/M2KrVjs/empty-grid.jpg)<br>
This is a grid, the gray square in the middle is the tile we’re currently counting the surrounding wall tiles for. Now let’s give our gray square some neighbors (red is a wall tile, blue is a floor tile):<br>
![Full Grid](https://i.ibb.co/DWXrZmB/griddd.jpg)<br>
Based on the rules of this cellular automaton, this tile will turn into a floor tile, because there are 4 wall tiles (4 red squares) surrounding it. Now, let’s code this neighbor counting function, we’ll call this function ``get_neighbor_count()`` and it will accept 3 arguments: `x` and `y` (which represents the tile’s position in our 2d list), and `grid`.

We’ll now iterate over the neighbors of this x and y position, to do this, we’ll need two loops, one that goes through the y position above and below the current tile, so `y+1` and `y-1` (Because we’re working with a 2d list y+1 represents the y position below the current tile, while y-1 represents the position above the current tile. This is because of array indexing), and one that goes through the item’s besides the tile (because of the way our loops are nested, we'll also be able to go through the item's diagonal to the current tile).

## Installation
Simply head over to the releases, download the `.zip` file, extract it, and run the `.exe` file.
